package testmtx

import (
	"errors"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io"
	"os"
	"strings"

	"github.com/iancoleman/strcase"
)

var (
	importMap       = map[string]string{}
	enumPropertyMap = map[string]*enumProperty{}

	repeated = 2 // overwritten by option
)

type enumProperty struct {
	name, value bool
}

func (e *enumProperty) valid() bool {
	return e.name && e.value
}

// PropGenerator is a struct to generate a property list with Go type.
// Create it using NewPropGenerator function.
type PropGenerator struct {
	w           io.Writer
	parser      *Parser
	repeatCount int
}

// NewPropGenerator creates a new PropGenerator.
// You can change some parameters of the PropGenerator with PropGenOption.
func NewPropGenerator(options ...PropGenOption) (*PropGenerator, error) {
	parser, err := NewParser()
	if err != nil {
		return nil, err
	}
	p := PropGenerator{
		w:           os.Stdout,
		parser:      parser,
		repeatCount: 3,
	}
	for _, opt := range options {
		err := opt(&p)
		if err != nil {
			return nil, err
		}
	}
	return &p, nil
}

// PropGenOption changes some parameters of the PropGenerator.
type PropGenOption func(*PropGenerator) error

// GenWriter changes the writer of the PropGenerator.
func GenWriter(w io.Writer) PropGenOption {
	return func(g *PropGenerator) error {
		g.w = w
		return nil
	}
}

// PropLevel4Gen changes the property level on the spreadsheet.
func PropLevel4Gen(level int) PropGenOption {
	return func(g *PropGenerator) error {
		if level < 1 {
			return errors.New("Property level should be positive value")
		}
		g.parser.propEndClm = g.parser.propStartClm + level - 1
		g.parser.typeClm = g.parser.propEndClm + 1
		g.parser.caseStartClm = g.parser.typeClm + 1
		return nil
	}
}

// RepeatCount changes the repeat count of the array properties.
func RepeatCount(c int) PropGenOption {
	return func(g *PropGenerator) error {
		if c < 1 {
			return errors.New("Repeat count should be positive value")
		}
		g.repeatCount = c
		return nil
	}
}

// Generate is a method to generate a property list with Go type.
func (g *PropGenerator) Generate(file, tName string) error {

	if g == nil {
		return errors.New("PropGenerator is not initilized")
	}

	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, file, nil, 0)
	if err != nil {
		return err
	}

	// preparation
	for _, d := range f.Decls {
		if gd, ok := d.(*ast.GenDecl); ok {
			for _, s := range gd.Specs {
				if is, ok := s.(*ast.ImportSpec); ok {
					importMap[is.Name.Name] = is.Path.Value
				}
				// a type that satisfies the following conditions is an ENUM type generated by grpc
				// - the base type is "int32"
				// - variables with "_name", "_value" appended at the end are defined
				if ts, ok := s.(*ast.TypeSpec); ok {
					if id, ok := ts.Type.(*ast.Ident); ok {
						if id.Name == "int32" {
							enumPropertyMap[ts.Name.Name] = &enumProperty{}
						}
					}
				}
				if vs, ok := s.(*ast.ValueSpec); ok {
					if strings.Index(vs.Names[0].Name, "_name") > 0 {
						if ep, ok := enumPropertyMap[vs.Names[0].Name[0:len(vs.Names[0].Name)-5]]; ok {
							ep.name = true
						}
					}
					if strings.Index(vs.Names[0].Name, "_value") > 0 {
						if ep, ok := enumPropertyMap[vs.Names[0].Name[0:len(vs.Names[0].Name)-6]]; ok {
							ep.value = true
						}
					}
				}
			}
		}
	}

	// output
	for _, d := range f.Decls {
		if gd, ok := d.(*ast.GenDecl); ok {
			for _, s := range gd.Specs {
				if ts, ok := s.(*ast.TypeSpec); ok {
					if ts.Name.Name == tName {
						fmt.Fprint(g.w, strcase.ToSnake(tName))
						g.outTab4Type(g.w, 0)
						return g.outData(g.w, ts.Type, 0)
					}
				}
			}
		}
	}

	return fmt.Errorf("Type not found (%s)", tName)
}

func (g *PropGenerator) outData(w io.Writer, d ast.Expr, i int) error {

	if i >= g.parser.maxPropLevel() {
		return fmt.Errorf("Type hierarchy exceeds the property level (%d)", g.parser.maxPropLevel())
	}

	var err error

	switch t := d.(type) {
	case *ast.StructType:
		err = g.outObject(w, t, i)
	case *ast.ArrayType:
		err = g.outArray(w, t, i)
	case *ast.Ident:
		err = g.outIdent(w, t, i)
	case *ast.SelectorExpr:
		err = g.outSelectorExpr(w, t, i)
	case *ast.StarExpr:
		err = g.outData(w, t.X, i)
	default:
		return fmt.Errorf("Don't support type (%+v)", t)
	}

	return err
}

func (g *PropGenerator) outObject(w io.Writer, t *ast.StructType, i int) error {
	fmt.Fprintln(w, typeObj)

	for _, f := range t.Fields.List {
		g.outTab(w, i+1)
		if err := g.outKeyName(w, f.Tag); err != nil {
			return err
		}
		g.outTab4Type(w, i+1)
		if err := g.outData(w, f.Type, i+1); err != nil {
			return err
		}
	}

	return nil
}

func (g *PropGenerator) outArray(w io.Writer, t *ast.ArrayType, i int) error {
	fmt.Fprintln(w, typeAry)

	for j := 0; j < repeated; j++ {
		g.outTab(w, i+1)
		fmt.Fprintf(w, "* %d", j)
		g.outTab4Type(w, i+1)
		err := g.outData(w, t.Elt, i+1)
		if err != nil {
			return err
		}
	}

	return nil
}

func (g *PropGenerator) outIdent(w io.Writer, t *ast.Ident, i int) error {

	tName := ""
	switch t.Name {
	case "string", "rune":
		tName = typeStr
	case "int", "int8", "int16", "int32", "int64", "uint", "uint8", "uint16", "uint32", "uint64", "float32", "float64":
		tName = typeNum
	case "bool":
		tName = typeBool
	default:
		if ep, ok := enumPropertyMap[t.Name]; ok && ep.valid() {
			tName = typeStr
		} else {
			if t.Obj != nil {
				if ts, ok := t.Obj.Decl.(*ast.TypeSpec); ok {
					return g.outData(w, ts.Type, i)
				}
			}
			panic(fmt.Sprintf("Don't expected type (%s)", t.Name))
		}
	}

	fmt.Fprintln(w, tName)

	return nil
}

func (g *PropGenerator) outSelectorExpr(w io.Writer, t *ast.SelectorExpr, i int) error {

	var impPath string
	if x, ok := t.X.(*ast.Ident); ok {
		if pt, ok := importMap[x.Name]; ok {
			impPath = pt
		}
	}

	tName := ""
	switch impPath {
	case "\"github.com/golang/protobuf/ptypes/timestamp\"":
		if t.Sel.Name == "Timestamp" {
			tName = typeStr
		}
	case "\"github.com/golang/protobuf/ptypes/wrappers\"":
		switch t.Sel.Name {
		case "StringValue", "BytesValue":
			tName = typeStr
		case "Int32Value", "Int64Value", "UInt32Value", "UInt64Value", "FloatValue", "DoubleValue":
			tName = typeNum
		case "BoolValue":
			tName = typeBool
		}
	}

	if tName == "" {
		// if can't search, user modifies output data manually
		tName = fmt.Sprintf("<%s>", t.Sel.Name)
	}

	fmt.Fprintln(w, tName)

	return nil
}

func (g *PropGenerator) outTab(w io.Writer, i int) {
	for j := 0; j < i; j++ {
		fmt.Fprint(w, "\t")
	}
}

func (g *PropGenerator) outTab4Type(w io.Writer, i int) {
	g.outTab(w, g.parser.maxPropLevel()-i)
}

func (g *PropGenerator) outKeyName(w io.Writer, tag *ast.BasicLit) error {

	if tag == nil {
		return errors.New("JSON tag not found")
	}

	pre := "json:\""
	s := strings.Index(tag.Value, pre) + len(pre)
	e := strings.Index(tag.Value[s:], "\"") + s
	fmt.Fprint(w, strings.Split(tag.Value[s:e], ",")[0])

	return nil
}
