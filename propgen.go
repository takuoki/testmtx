package testmtx

import (
	"errors"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io"
	"os"
	"strings"

	"github.com/iancoleman/strcase"
)

// PropGenerator is a struct to generate a property list with Go type.
// Create it using NewPropGenerator function.
type PropGenerator struct {
	w           io.Writer
	parser      *Parser
	repeatCount int

	parsedFiles  []*ast.File
	preparedData *preparedData
}

type preparedData struct {
	importMap       map[string]string
	enumPropertyMap map[string]*enumProperty
}

type enumProperty struct {
	name, value bool
}

func (e *enumProperty) valid() bool {
	return e.name && e.value
}

// NewPropGenerator creates a new PropGenerator.
// You can change some parameters of the PropGenerator with PropGenOption.
func NewPropGenerator(options ...PropGenOption) (*PropGenerator, error) {
	parser, err := NewParser()
	if err != nil {
		return nil, err
	}
	p := PropGenerator{
		w:           os.Stdout,
		parser:      parser,
		repeatCount: 2,
	}
	for _, opt := range options {
		err := opt(&p)
		if err != nil {
			return nil, err
		}
	}
	return &p, nil
}

// PropGenOption changes some parameters of the PropGenerator.
type PropGenOption func(*PropGenerator) error

// GenWriter changes the writer of the PropGenerator.
func GenWriter(w io.Writer) PropGenOption {
	return func(g *PropGenerator) error {
		g.w = w
		return nil
	}
}

// PropLevel4Gen changes the property level on the spreadsheet.
func PropLevel4Gen(level int) PropGenOption {
	return func(g *PropGenerator) error {
		if level < 1 {
			return errors.New("property level should be positive value")
		}
		g.parser.propEndClm = g.parser.propStartClm + level - 1
		g.parser.typeClm = g.parser.propEndClm + 1
		g.parser.caseStartClm = g.parser.typeClm + 1
		return nil
	}
}

// RepeatCount changes the repeat count of the array properties.
func RepeatCount(c int) PropGenOption {
	return func(g *PropGenerator) error {
		if c < 1 {
			return errors.New("repeat count should be positive value")
		}
		g.repeatCount = c
		return nil
	}
}

// GenerateDir is a method to generate a property list with Go type.
func (g *PropGenerator) GenerateDir(path, tName string) error {

	if g == nil {
		return errors.New("propGenerator is not initilized")
	}

	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, path, nil, 0)
	if err != nil {
		return err
	}

	g.parsedFiles = packagesToFiles(pkgs)
	g.preparate()

	// output
	d, ok := g.findType(tName)
	if !ok {
		return fmt.Errorf("type not found (%s)", tName)
	}

	fmt.Fprint(g.w, strcase.ToSnake(tName))
	g.outTab4Type(g.w, 0)
	return g.outData(g.w, d, 0)
}

// Generate is a method to generate a property list with Go type.
func (g *PropGenerator) Generate(file, tName string) error {

	if g == nil {
		return errors.New("propGenerator is not initilized")
	}

	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, file, nil, 0)
	if err != nil {
		return err
	}

	g.parsedFiles = []*ast.File{f}
	g.preparate()

	// output
	d, ok := g.findType(tName)
	if !ok {
		return fmt.Errorf("type not found (%s)", tName)
	}

	fmt.Fprint(g.w, strcase.ToSnake(tName))
	g.outTab4Type(g.w, 0)
	return g.outData(g.w, d, 0)
}

func (g *PropGenerator) preparate() {

	g.preparedData = &preparedData{
		importMap:       map[string]string{},
		enumPropertyMap: map[string]*enumProperty{},
	}

	// preparation
	for _, f := range g.parsedFiles {
		for _, d := range f.Decls {
			if gd, ok := d.(*ast.GenDecl); ok {
				for _, s := range gd.Specs {
					if is, ok := s.(*ast.ImportSpec); ok {
						if is.Name == nil {
							n := is.Path.Value[strings.LastIndex(is.Path.Value, "/")+1 : len(is.Path.Value)-1]
							g.preparedData.importMap[n] = is.Path.Value
						} else {
							g.preparedData.importMap[is.Name.Name] = is.Path.Value
						}
					}
					// a type that satisfies the following conditions is an ENUM type generated by grpc
					// - the base type is "int32"
					// - variables with "_name", "_value" appended at the end are defined
					if ts, ok := s.(*ast.TypeSpec); ok {
						if id, ok := ts.Type.(*ast.Ident); ok {
							if id.Name == "int32" {
								g.preparedData.enumPropertyMap[ts.Name.Name] = &enumProperty{}
							}
						}
					}
					if vs, ok := s.(*ast.ValueSpec); ok {
						if strings.Index(vs.Names[0].Name, "_name") > 0 {
							if ep, ok := g.preparedData.enumPropertyMap[vs.Names[0].Name[0:len(vs.Names[0].Name)-5]]; ok {
								ep.name = true
							}
						}
						if strings.Index(vs.Names[0].Name, "_value") > 0 {
							if ep, ok := g.preparedData.enumPropertyMap[vs.Names[0].Name[0:len(vs.Names[0].Name)-6]]; ok {
								ep.value = true
							}
						}
					}
				}
			}
		}
	}
}

func (g *PropGenerator) findType(tName string) (ast.Expr, bool) {
	for _, f := range g.parsedFiles {
		for _, d := range f.Decls {
			if gd, ok := d.(*ast.GenDecl); ok {
				for _, s := range gd.Specs {
					if ts, ok := s.(*ast.TypeSpec); ok {
						if ts.Name.Name == tName {
							return ts.Type, true
						}
					}
				}
			}
		}
	}
	return nil, false
}

func (g *PropGenerator) outData(w io.Writer, d ast.Expr, i int) error {

	if i >= g.parser.maxPropLevel() {
		return fmt.Errorf("type hierarchy exceeds the property level (%d)", g.parser.maxPropLevel())
	}

	switch t := d.(type) {
	case *ast.StructType:
		return g.outObject(w, t, i)
	case *ast.ArrayType:
		return g.outArray(w, t, i)
	case *ast.Ident:
		return g.outIdent(w, t, i)
	case *ast.SelectorExpr:
		return g.outSelectorExpr(w, t, i)
	case *ast.StarExpr:
		return g.outData(w, t.X, i)
	default:
		return fmt.Errorf("don't support type (%+v)", t)
	}
}

func (g *PropGenerator) outObject(w io.Writer, t *ast.StructType, i int) error {
	fmt.Fprintln(w, typeObj)

	for _, f := range t.Fields.List {
		key := g.getKeyName(f.Tag)
		if key == "" {
			continue
		}
		g.outTab(w, i+1)
		fmt.Fprint(w, key)
		g.outTab4Type(w, i+1)
		if err := g.outData(w, f.Type, i+1); err != nil {
			return err
		}
	}

	return nil
}

func (g *PropGenerator) outArray(w io.Writer, t *ast.ArrayType, i int) error {
	fmt.Fprintln(w, typeAry)

	for j := 0; j < g.repeatCount; j++ {
		g.outTab(w, i+1)
		fmt.Fprintf(w, "* %d", j)
		g.outTab4Type(w, i+1)
		err := g.outData(w, t.Elt, i+1)
		if err != nil {
			return err
		}
	}

	return nil
}

func (g *PropGenerator) outIdent(w io.Writer, t *ast.Ident, i int) error {

	tName := ""
	switch t.Name {
	case "string", "rune":
		tName = typeStr
	case "int", "int8", "int16", "int32", "int64", "uint", "uint8", "uint16", "uint32", "uint64", "float32", "float64":
		tName = typeNum
	case "bool":
		tName = typeBool
	default:
		if ep, ok := g.preparedData.enumPropertyMap[t.Name]; ok && ep.valid() {
			tName = typeStr
		} else {
			if t.Obj != nil {
				if ts, ok := t.Obj.Decl.(*ast.TypeSpec); ok {
					return g.outData(w, ts.Type, i)
				}
			}
			if d, ok := g.findType(t.Name); ok {
				return g.outData(w, d, i)
			}
			// if can't search, user modifies output data manually
			tName = fmt.Sprintf("<%s>", t.Name)
		}
	}

	fmt.Fprintln(w, tName)

	return nil
}

func (g *PropGenerator) outSelectorExpr(w io.Writer, t *ast.SelectorExpr, i int) error {

	var impPath string
	if x, ok := t.X.(*ast.Ident); ok {
		if pt, ok := g.preparedData.importMap[x.Name]; ok {
			impPath = pt
		}
	}

	tName := ""
	switch impPath {
	case "\"github.com/golang/protobuf/ptypes/timestamp\"":
		if t.Sel.Name == "Timestamp" {
			tName = typeStr
		}
	case "\"github.com/golang/protobuf/ptypes/wrappers\"":
		switch t.Sel.Name {
		case "StringValue", "BytesValue":
			tName = typeStr
		case "Int32Value", "Int64Value", "UInt32Value", "UInt64Value", "FloatValue", "DoubleValue":
			tName = typeNum
		case "BoolValue":
			tName = typeBool
		}
	}

	if tName == "" {
		// if can't search, user modifies output data manually
		tName = fmt.Sprintf("<%s>", t.Sel.Name)
	}

	fmt.Fprintln(w, tName)

	return nil
}

func (g *PropGenerator) outTab(w io.Writer, i int) {
	for j := 0; j < i; j++ {
		fmt.Fprint(w, "\t")
	}
}

func (g *PropGenerator) outTab4Type(w io.Writer, i int) {
	g.outTab(w, g.parser.maxPropLevel()-i)
}

func (g *PropGenerator) getKeyName(tag *ast.BasicLit) string {

	if tag == nil {
		return ""
	}

	pre := "json:\""
	s := strings.Index(tag.Value, pre) + len(pre)
	e := strings.Index(tag.Value[s:], "\"") + s
	return strings.Split(tag.Value[s:e], ",")[0]
}

func packagesToFiles(pkgs map[string]*ast.Package) []*ast.File {
	fs := []*ast.File{}
	for _, p := range pkgs {
		for _, f := range p.Files {
			fs = append(fs, f)
		}
	}
	return fs
}
